---
title: "Ace inhibitors LPA"
author: "Will A. S. Hardy"
date: "27/01/2021"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
##### Packages #####
library(tidyverse) # needed for data manipulation.
library(tsibble)
library(tidyLPA)
library(future)
library(furrr)
library(tidymodels)
library(workflows)
library(tune)
library(nnet)
library(brms) # for the analysis
library(RColorBrewer) # needed for some extra colours in one of the graphs
library(ggmcmc)
library(ggthemes)
library(ggridges)
library(RcppEigen)
library(knitr)

options(mc.cores = parallel::detectCores() - 1)

knitr::opts_chunk$set(echo = TRUE, cache = TRUE)

set.seed(32)

gp <- 
  read_rds("../OneDrive/2_interimdata/8_linkeddata/gp_agesex_qof_combined.rds") %>% 
  mutate(npat = N,
         N = NULL,
         practice_id = as_factor(practiceid),
         dispensing = as_factor(dispensing),
         cluster = as_factor(cluster),
         hboard = as_factor(str_remove_all(hboard, "W110000")),
         gp_load = npat/ngp) %>% 
  ungroup() %>% 
  janitor::clean_names()

differences_files <- 
  list.files("../data/differences/")
names(differences_files) <- 
  str_remove_all(differences_files, "_discreps.rds")

differences <- 
  map_dfr(.x = differences_files,
          .f = ~read_rds(paste0("../data/differences/", .x)),
          .id = "drug") %>% 
  mutate(drug = as_factor(drug)) %>% 
  select(drug, regional_unit, datename, discrepancy)

proportions <- 
  map_dfr(.x = differences_files,
          .f = ~read_rds(paste0("../data/differences/", .x)),
          .id = "drug") %>% 
  mutate(drug = as_factor(drug)) %>% 
  select(drug, regional_unit, datename, prop)

drugs <- unique(as.character(differences$drug))

#### Functions ####
# To colour code the extremes, we need to write a small function that calculates the regression lines and adds a column indicating which clusters have the most extreme.
f1 <- function(data, x, y, grouping, n.highest = 3, n.lowest = 3){
  groupinglevel <- data[,grouping]
  res           <- data.frame(coef = rep(NA, length(unique(groupinglevel))), group = unique(groupinglevel))
  names(res)    <- c("coef", grouping)
  for(i in 1:length(unique(groupinglevel))){
    data2    <- as.data.frame(data[data[,grouping] == i,])
    res[i,1] <- as.numeric(lm(data2[, y] ~ data2[, x])$coefficients[2])
  }
  top    <- res %>% top_n(n.highest, coef)
  bottom <- res %>% top_n(-n.lowest, coef)
  res    <- res %>% mutate(high_and_low = ifelse(coef %in% top$coef, "top",  ifelse(coef %in% bottom$coef, "bottom", "none")))
  data3  <- left_join(data, res)
  return(data3)
}

modelParams <- function(model){
  posterior_summary(model) %>% 
  as_tibble(rownames = NA) %>% 
  rownames_to_column(var = "Parameter") %>% 
  filter(!str_detect(Parameter, "r_team"),
         !str_detect(Parameter, "L_"),
         !str_detect(Parameter, "z_"))
}

bayesEstimate <- function(.){
  require(papaja)
  paste0(printnum(.$Estimate), "[", printnum(.$Q2.5), ",", printnum(.$Q97.5), "]")
}

plotSlopes <- function(data, resp, efflist, group) {
  require(ggplot2)
  require(purrr)
  y <- enquo(resp)
  group <- enquo(group)
  ngroups <- data %>% 
    select(!!group) %>% 
    unique() %>% 
    nrow()

  map(efflist, function(x)
    ggplot(data, aes(!!sym(x), !!y, col = as.numeric(!!group), 
                     group = !!group)) +
    geom_point(size = 1.2,
               alpha = .8,
               position = "jitter") + # to add some random noise for plotting purposes
    theme_minimal() +
    theme(legend.position = "none") +
    scale_color_gradientn(colours = rainbow(n = ngroups)) +
    geom_smooth(method = lm,
                se     = FALSE,
                size   = .5,
                alpha  = .8) + # to add regression line
    ylab(NULL)
  )
}
```


## Data cleaning

```{r, data-problem-values, warning=FALSE}
differences %>% 
  pivot_wider(names_from = datename, values_from = discrepancy) %>% 
  psych::describeBy(group = "drug", fast = TRUE)

proportions %>% 
  pivot_wider(names_from = datename, values_from = prop) %>% 
  psych::describeBy(group = "drug", fast = TRUE)
```

* Problem with `oac` data
* Infinite values have been calculated when something has been divided by zero. Is this when the total prescribing of oac has been zero, thus wafarin as a percentage of 0 is Inf?

```{r, data-which-problem}
differences %>% 
  filter(drug == "oac" & 
           (is.na(discrepancy) | is.nan(discrepancy) | is.infinite(discrepancy))) %>% 
  group_by(datename) %>% 
  count()

differences %>% 
  filter(drug == "oac" & 
           (is.na(discrepancy) | is.nan(discrepancy) | is.infinite(discrepancy))) %>% 
  group_by(drug, regional_unit) %>% 
  count()
```

* Missing/inappropriate data in five practices
* Removed these practices from the `oac` data

```{r, data-cleaning}
differences <- 
  differences %>% 
  anti_join(y = differences %>% 
              filter(drug == "oac" & 
                       (is.na(discrepancy) |
                          is.nan(discrepancy) | 
                          is.infinite(discrepancy))) %>% 
              group_by(drug, regional_unit) %>% 
              count(), 
            by = c("drug", "regional_unit"))

differences_wide <- 
  differences %>% 
  pivot_wider(names_from = datename, values_from = discrepancy)

proportions_wide <- 
  proportions %>% 
  filter(drug == "ace") %>% 
  pivot_wider(names_from = datename, values_from = prop)
```


## Disease profiles

```{r}
df <- select(filter(gp, year == "2020"), p_fem:flu)
psych::fa.parallel(df)
five_fac <- psych::fa(df, nfactors = 4, rotate = "varimax")
print(five_fac$loadings, cutoff = .2)

dis_pca <- psych::principal(df, nfactors = 3, scores = TRUE)
plot(dis_pca$values)
dis_pca$rotation
dis_pca_scores <- bind_cols(practice_id = filter(gp, year == "2020")$practice_id, dis_pca$scores)

# 2d plot
x <- dis_pca$loadings[,1]
y <- dis_pca$loadings[,2]
z <- dis_pca$loadings[,3]

pca_plot_df <- bind_cols(dis = names(x), x = x, y = y, z = z)

ggplot(aes(x = x, y = y), data = pca_plot_df) +
  geom_text(aes(label = dis))

ggplot(aes(x = x, y = z), data = pca_plot_df) +
  geom_text(aes(label = dis))

# 3d plot
plotly::plot_ly(x=x, y=y, z=z, data = pca_plot_df,
                type="scatter3d", mode="text", text = ~dis)
```


## MLM

```{r}
mlm_df <- 
  proportions_wide %>% 
  left_join(gp, by = c("regional_unit" = "practice_id")) %>% 
  rename(march = `2020 Mar`, april = `2020 Apr`, may = `2020 May`, 
         june = `2020 Jun`, july = `2020 Jul`, august = `2020 Aug`)
```


### March

```{r}
mlm_df %>% 
  ggplot(aes(x = gp_load, y = march, 
             col = as.numeric(cluster), group = cluster)) +
 geom_point(size = .2,
             alpha = .8,
             position = "jitter") +# to add some random noise for plotting purposes
  theme_minimal() +
  theme(legend.position = "none") +
    scale_color_gradientn(colours = rainbow(length(unique(gp$cluster)))) +
  geom_smooth(method = lm,
              se     = FALSE,
              size   = .5,
              alpha  = .8) # to add regression line
```

#### Analysis 1 {.tabset}
##### Intercept only model

```{r, mar-int-cluster-model, include=FALSE}
mar_interceptonlymodel <- 
  brm(march ~ 1 + (1|cluster),  
      data = mlm_df, 
      warmup = 1000, iter = 3000, seed = 123, save_pars = save_pars(all = TRUE)) 

mar_interceptonlyparams <- modelParams(mar_interceptonlymodel)

# Calculating ICC
hyp <- "sd_cluster__Intercept^2 / (sd_cluster__Intercept^2 + sigma^2) = 0"
mar_icc_test <- print(hypothesis(mar_interceptonlymodel, hyp, class = NULL))
mar_icc_est <- paste0(mar_icc_test$hypothesis$Estimate, " [", mar_icc_test$hypothesis$CI.Lower, ",",
       mar_icc_test$hypothesis$CI.Upper, "]")
```


```{r, mar-int-cluster-convergence}
mar_interceptonlymodel %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 1000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```

```{r, mar-int-cluster-params}
mar_interceptonlyparams %>% 
  kable(digits = 2)
```

* Posterior mean of residual variance at team level = `r mar_interceptonlyparams[2,2]^2`
* Posterior mean of residual variance at individual level = `r mar_interceptonlyparams[3,2]^2`
* ICC: $\rho$ = `r mar_icc_est`

##### L1 predictors

```{r, mar-m1-cluster-model}
mar_mlm1 <- brm(march ~ 1 + p_fem + pm_65 + dispensing + wimd2019 + gp_load +
              (1|cluster),  
      data = mlm_df, 
      warmup = 1000, iter = 3000, seed = 123, save_pars = save_pars(all = TRUE)) 

mar_mlm1_params <- modelParams(mar_mlm1)
```


```{r, mar-m1-cluster-convergence}
mar_mlm1 %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept", "b_p_fem", "b_pm_65", "b_dispensingYes",
                          "b_wimd2019", "b_gp_load")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 1000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```


```{r, mar-m1-cluster-params}
mar_mlm1_params %>% 
  kable(digits = 2)
```


##### L1 predictors with random slopes

```{r, mar-mlm2-cluster-model}
mar_mlm2 <- brm(march ~ 1 + p_fem + pm_65 + dispensing + wimd2019 + gp_load +
              (1 + p_fem + pm_65 + dispensing + wimd2019 + gp_load|cluster),  
      data = mlm_df, 
      warmup = 2000, iter = 6000, seed = 123, save_pars = save_pars(all = TRUE),
      control = list(max_treedepth = 15))

mar_mlm2_params <- modelParams(mar_mlm2)
```


```{r, mar-m2-cluster-convergence}
mar_mlm2 %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept", "b_p_fem", "b_pm_65", "b_dispensingYes",
                          "b_wimd2019", "b_gp_load")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 2000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```


```{r, mar-m2-cluster-params}
mar_mlm2_params %>% 
  kable(digits = 2)
```



### Apr


#### Analysis 1 {.tabset}
##### Intercept only model

```{r apr-intercept-cluster-model, include=FALSE}
apr_interceptonlymodel <- 
  brm(april ~ 1 + (1|cluster),  
      data = mlm_df, 
      warmup = 1000, iter = 3000, seed = 123, save_pars = save_pars(all = TRUE)) 

apr_interceptonlyparams <- modelParams(apr_interceptonlymodel)

# Calculating ICC
apr_hyp <- "sd_cluster__Intercept^2 / (sd_cluster__Intercept^2 + sigma^2) = 0"
apr_icc_test <- print(hypothesis(apr_interceptonlymodel, apr_hyp, class = NULL))
apr_icc_est <- paste0(apr_icc_test$hypothesis$Estimate, 
                  " [", apr_icc_test$hypothesis$CI.Lower, ",",
                  apr_icc_test$hypothesis$CI.Upper, "]")
```


```{r, apr-int-cluster-convergence}
apr_interceptonlymodel %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 1000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```


```{r apr-intercept-cluster-params}
apr_interceptonlyparams %>% 
  kable(digits = 2)
```

* Posterior mean of residual variance at team level = `r apr_interceptonlyparams[2,2]^2`
* Posterior mean of residual variance at individual level = `r apr_interceptonlyparams[3,2]^2`
* ICC: $\rho$ = `r apr_icc_est`

##### L1 predictors

```{r, apr-m1-cluster-model, include=FALSE}
apr_mlm1 <- brm(april ~ 1 + march +
                 p_fem + pm_65 + dispensing + wimd2019 + gp_load +
              (1|cluster),  
      data = mlm_df, 
      warmup = 1000, iter = 3000, seed = 123, save_pars = save_pars(all = TRUE)) 

apr_mlm1_params <- modelParams(apr_mlm1)
```


```{r, apr-m1-cluster-convergence}
apr_mlm1 %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept", "b_march", "b_p_fem", "b_pm_65", 
                          "b_dispensingYes", "b_wimd2019", "b_gp_load")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 1000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```


```{r, apr-m1-cluster-params}
apr_mlm1_params %>% 
  kable(digits = 2)
```

##### L1 predictors with random slopes

```{r, apr-m2-cluster-model, include=FALSE}
apr_mlm2 <- brm(march ~ 1 + march +
                  p_fem + pm_65 + dispensing + wimd2019 + gp_load +
                  (1 + march +
                     p_fem + pm_65 + dispensing + wimd2019 + gp_load|cluster), 
      data = mlm_df, 
      warmup = 1000, iter = 3000, seed = 123, save_pars = save_pars(all = TRUE),
      control = list(max_treedepth = 15)) 

apr_mlm2_params <- modelParams(apr_mlm2)
```

```{r, apr-m2-cluster-convergence}
apr_mlm2 %>% 
  ggs() %>% 
  filter(Parameter %in% c("b_Intercept", "b_march", "b_p_fem", "b_pm_65", 
                          "b_dispensingYes", "b_wimd2019", "b_gp_load")) %>% 
  ggplot(aes(x = Iteration, y = value, col = as.factor(Chain))) +
  geom_line() +
  geom_vline(xintercept = 1000) +
  facet_grid(Parameter ~ .,
             scale = "free_y",
             switch = "y")
```


```{r, apr-m2-cluster-params}
apr_mlm2_params %>% 
  kable(digits = 2)
```


```{r}

```

